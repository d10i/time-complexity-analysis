\chapter{Implementation}

This chapter discusses how the software has been implemented. Section \ref{sec:implementation:overview} gives an overview about the tools and techniques being used. Sections \ref{sec:implementation:annotations}-\ref{sec:implementation:timecomplexityanalyser} will discuss the implementation of each existing module that has been introduced in the previous chapter.

\section{Overview}
\label{sec:implementation:overview}

\subsection{Important considerations}
As mentioned in previous chapters, one of the most important aspects of the product is to limit the observer effect. It is extremely important that the act of instrumenting and analysing the algorithm under test has the smallest possible impact on the algorithm's performance. Performance in programs that run on the JVM is also impacted be the garbage collection, given that when that happens all the threads are temporarily paused. This means that the act of collecting measurements must not have a big impact on memory, or the garbage collection will happen too often having a great impact on the algorithm's performance.

\noindent Considering this, it would be very hard, if not impossible, to come up with the theory supporting the instrumentation and measuring logic. Instead, different implementations will be attempted, discussed and compared in the following sections. All the different approaches will of course keep performance and memory usage in mind.

\subsection{Modules and dependencies}
The modules discussed in the previous chapters are defined as Maven\footnote{\url{https://maven.apache.org/}} modules. Maven is a tool that can be used to build and manage Java-based projects. Modules can be defined via a \code{pom.xml} file in the module's root folder, specifying the module group ID, artifact ID, version and the dependencies it has on other Maven modules. Maven dependencies could be defined by the user or could be 3rd party modules that exist in Maven public repositories. An example of a \code{pom.xml} file can be find in Appendix \ref{sec:appendices:examplepomfile}.

\subsection{Testing}
The concept of test-driven development (TDD) is applied to all modules. Tests that describe requirements are written prior to the implementation, then the implementation is added ensuring that the tests pass. This process inspires confidence, makes the software more robust and allows for easy refactoring. On top of that, benchmarks are used across modules that are performance-critical, ensuring the CPU time they use is minimal.

\subsection{Logging and debugging}
For this product's implementation, logging is very useful for:
\begin{itemize}
  \item Show debugging information, used to address problems such as bugs and performance issues
  \item Pointing to the line of code that caused an exception
  \item Better understanding of the application flow, especially for the users that don't know about the underlying software implementation
\end{itemize}

\noindent Simple Logging Facade for Java (SLF4J)\footnote{\url{https://www.slf4j.org/}} is an abstraction over different Java logging frameworks such as \code{java.util.logging}, \code{logback} and \code{log4j}. All the modules described in the following sections use the SLF4J API for logging.

\noindent The actual SLF4J implementation is only defined and configured at runtime, specifically in the root module (Time complexity analyser) via a Maven dependency and a configuration file. Logback is highly customisable and the log granularity can be configured on a per-package basis. During development it's often useful to show debugging information for the specific modules that are being worked on. Logging has an impact on performance so in the final implementation the logging should be minimal. Logback makes it very easy to change configuration via a \code{logback.xml} file that lives in the \code{src/main/resources} folder.

\noindent Most 3rd party Maven modules already use the SLF4J API but for the ones that don't SLF4J also offers bridges which redirect calls the legacy loggers to behave as if they were made to the SLF4J API instead.

\subsection{Disclaimer}
Code snippets included in the following sections have some differences compared to real product code:
\begin{itemize}
  \item Indentation in this document is 1 space character, compared to 2 spaces in the real code
  \item Log lines are removed
  \item Imports are omitted
  \item Some keywords, such as \code{final}, are sometimes removed
\end{itemize}

\noindent All these differences are purely made for a question of space and to only show the part of the code that is relevant and important.

\section{Annotations}
\label{sec:implementation:annotations} 
This module defines a package \code{tech.dario.timecomplexityanalysis.annotations} which simply contains one single annotation, shown in Listing \ref{lis:measured}.
\begin{lstlisting}[caption={Measured annotation},label=lis:measured]
public %%@interface%% Measured {
}
\end{lstlisting}

\noindent The annotation can be added to any method and any class and informs the agent that the entity should be time-measured (see next chapter).


\section{Agent}
\label{sec:implementation:agent} 
This module defines a package \code{tech.dario.timecomplexityanalysis.agent} containing the logic to instrument methods in order to measure how long they took and report it to the time recorder implementation. When built, this module produces a JAR file that can be used as a Java agent, as explained in Section \ref{sec:design:agent}.

\noindent The \code{MeasuringAgent} class in Listing \ref{lis:measuringagent} defines a \code{premain} method which is called after the Java Virtual Machine (JVM) is initialized and before the \code{main} method is called. This method registers a \code{MeasuringClassFileTransformer} which instruments classes as they get loaded. If the path to a configuration file is passed to the agent as an argument, the file is parsed and the configuration parameters are passed to the class file transformer. Otherwise it uses the default configuration (see Section \ref{sec:implementation:agent:configuration}).

\begin{lstlisting}[breaklines,caption={$MeasuringAgent$ class},label=lis:measuringagent]
public class MeasuringAgent {
 public static void premain(
   String agentArguments,
   Instrumentation instrumentation) {
  try {
   Config config = getConfigFromArguments(agentArguments);
   instrumentation.addTransformer(
     new MeasuringClassFileTransformer(config)
   );
  } catch (Exception e) {
   e.printStackTrace();
   System.exit(1);
  }
 }

 private static Config getConfigFromArguments(String agentArguments) throws IOException {
  if (agentArguments == null || agentArguments.trim().isEmpty()) {
   // No arguments
   return Config.getDefault();
  }

  return Config.fromJsonFilePath(agentArguments);
 }
}
\end{lstlisting}

\subsection{Configuration}
\label{sec:implementation:agent:configuration}
The agent can be configured with four different parameters:
\begin{enumerate}
  \item \textbf{\code{whitelist}}: a set of regexes\footnote{Regular expressions} indicating what methods to instrument. Default: empty set
  \item \textbf{\code{blacklist}}: a set of regexes indicating what methods to not instrument. Default: empty set
  \item \textbf{\code{excludeStandardJavaLibrary}}: a flag indicating whether to exclude classes that are part of the standard Java 8 library\footnote{\code{java}, \code{javax}, \code{jdk}, \code{sun}, \code{com.oracle.net}, \code{com.sun}, \code{org.ietf.jgss} and \code{org.jcp.xml.dsig.internal} packages}. Default: \code{true}
  \item \textbf{\code{excludeStandardScalaLibrary}}:  a flag indicating whether to exclude classes that are part of the standard Scala library\footnote{\code{scala} package}. Default: \code{true}
\end{enumerate}

\noindent Listing \ref{lis:config1} shows an example of configuration which instructs the agent to insturment any method in the \code{tech.dario.timecomplexityanalysis.testalgorithm} package, excluding any method starting with \code{get}. The regexes specified in the \code{whitelist} and \code{blacklist} parameters should be in a format accepted by the \code{compile} method of \code{java.util.regex.Pattern}\footnote{\url{https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html}}. For example, method \code{tech.dario.timecomplexityanalysis.testalgorithm.MyClass.getName()} is both whitelisted and blacklisted. The whitelist regex matches \code{tech.dario.timecomplexityanalysis.testalgorithm} while the blacklist element matches \code{tech.dario.timecomplexityanalysis.testalgorithm.MyClass.get}. Because the blacklist element is more targeted, it takes priority over the whitelist element so the method is not instrumented (see Section \ref{sec:implementation:agent:transformation} for more details).

\begin{lstlisting}[breaklines,caption={Configuration JSON file example},label=lis:config1,style=json]
{
 "whitelist": [
  "^tech\\.dario\\.timecomplexityanalysis\\.testalgorithm\\."
 ],
 "blacklist": [
  "^tech\\.dario\\.timecomplexityanalysis\\.testalgorithm\\..+\\.get"
 ],
 "excludeStandardJavaLibrary": true,
 "excludeStandardScalaLibrary": true
}
\end{lstlisting}

\subsection{Transformation}
\label{sec:implementation:agent:transformation}

\code{MeasuringClassFileTransformer} constructor in Listing \ref{lis:measuringclassfiletransformer:constructor} accepts an instance of \code{Config} and saves it in a local field which can be accessed in the transformation. It also compiles the whitelist and blacklist regexes converting them from \code{String} to \code{Pattern} and saves them in two local fields of type \code{Set<Pattern>} called \code{whitelistPatterns} and \code{blacklistPatterns} respectively. Doing this step upfront decreases the time the transformation takes as it ensures that each regex is only compiled once as opposed to compiling it each time a method is checked for instrumentation.

\begin{lstlisting}[breaklines,caption={$MeasuringClassFileTransformer$ initialization},label=lis:measuringclassfiletransformer:constructor]
public class MeasuringClassFileTransformer implements ClassFileTransformer {

 ...

 private final Config config;
 private final Set<Pattern> whitelistPatterns;
 private final Set<Pattern> blacklistPatterns;

 public MeasuringClassFileTransformer(Config config) {
  this.config = config;
  this.whitelistPatterns = stringSetToPatternSet(config.getWhitelist());
  this.blacklistPatterns = stringSetToPatternSet(config.getBlacklist());
 }

 ...

 private Set<Pattern> stringSetToPatternSet(Set<String> stringSet) {
  if (stringSet == null) {
   return null;
  }

  return stringSet
    .stream()
    .map(Pattern::compile)
    .collect(Collectors.toSet());
 }
}
\end{lstlisting}

\noindent \code{MeasuringClassFileTransformer} implements \code{interface} \code{java.lang.instrument.ClassFileTransformer}\footnote{\url{https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/ClassFileTransformer.html}} which defines method \code{transform} shown in Listing \ref{lis:measuringclassfiletransformer:transform}. By implementing this interface, \code{MetricAgent} can use \code{MeasuringClassFileTransformer} as one of its transformers and because of that each class being loaded in the JVM will pass through this transformer for optional instrumentation. This class' responsibility is to determine whether the class being loaded should be instrumented and if so to instrument it.

\begin{lstlisting}[breaklines,caption={$MeasuringClassFileTransformer.transform$ implementation},label=lis:measuringclassfiletransformer:transform]
$$@Override
public byte[] transform(
  ClassLoader loader,
  String fullyQualifiedClassName,
  Class<?> classBeingRedefined,
  ProtectionDomain protectionDomain,
  byte[] classfileBuffer) throws IllegalClassFormatException {
 if (isClassExcludedByName(fullyQualifiedClassName)) {
  return null;
 }

 String className = fullyQualifiedClassName.replace("/", ".");
 CtClass ctClass = ClassPool.getDefault().get(className);
 if (isClassExcludedByImplementation(ctClass)) {
  return null;
 }

 declareAndInstantiateTimeRecorder(ctClass);

 boolean isClassModified = instrumentMeasuredMethods(ctClass);
 if (!isClassModified) {
  return null;
 }

 return ctClass.toBytecode();
}
\end{lstlisting}


\noindent The transformer first uses private method \code{isClassExcludedByName} to check whether the class should be excluded from instrumentation based on its fully qualified class name. As the documentation states, the name of the class passed in the method is in the internal form of fully qualified class names as defined in \textit{The Java Virtual Machine Specification} (e.g. \code{java/util/List}). A class will be excluded based on its fully qualified name if:
\begin{itemize}
  \item It's part of the standard Java library and the \code{excludeStandardJavaLibrary} configuration parameter is set to true, or
  \item It's part of the standard Scala library and the \code{excludeStandardScalaLibrary} configuration parameter is set to true, or
  \item It's part of the \code{javaassist} package or the \code{tech.dario.timecomplexityanalysis.timerecorder} package (this is to avoid instrumenting classes that are needed for instrumentation itself)
\end{itemize}

\noindent If the class is excluded, the method returns \code{null} which instructs the JVM that this class should be loaded without any instrumentation applied. Otherwise it loads the class from the default \code{ClassPool}\footnote{\url{https://jboss-javassist.github.io/javassist/html/javassist/ClassPool.html}} and uses private method \code{isClassExcludedByImplementation} to check whether the class should be excluded based on its implementation. In the context of instrumentation the term \enquote{class} is used in a more generic way and includes annotations, arrays, enums, interfaces and primitives too. \code{MeasuringClassFileTransformer} excludes any class that is not an actual class (i.e. defined with the \code{class} keyword) from instrumentation by returning \code{null}.

\noindent Now the time recorder is declared and instantiated in the class by using the private method \code{declareAndInstantiateTimeRecorder}. It instruments the class by declaring a private, static and final field called \code{\_AGENT\_TIME\_RECORDER} as shown in Listing \ref{lis:measuringclassfiletransformer:agenttimerecorder}. Note that at this point the instrumented class is using the time recorder API to report time and is unaware of what the actual time recorder implementation is. Section \ref{sec:implementation:timerecorderapi} will explain how the time recorder implementation is injected into the instrumented classes.

\begin{lstlisting}[breaklines,caption={$\_AGENT\_TIME\_RECORDER$ initialization},label=lis:measuringclassfiletransformer:agenttimerecorder]
private final static tech.dario.timecomplexityanalysis.timerecorder.api.TimeRecorder _AGENT_TIME_RECORDER = tech.dario.timecomplexityanalysis.timerecorder.api.StaticTimeRecorderFactory.getTimeRecorder();
\end{lstlisting}

\noindent The whitelisted methods now get instrumented using the private method \code{instrumentMeasuredMethods}. For each method of each class that is not excluded, the agent uses the logic in Listing \ref{lis:measuringclassfiletransformer:ismethodmeasured} to determine whether the method should be instrumented. It finds the best-matching whitelist regex and the best-matching blacklist regex. The longer the match, the better and more targeted it is considered to be. If the best-matching whitelist regex is more targeted than the best-matching blacklist regex (or as targeted, i.e. whitelists have priority over blacklists) then the method is instrumented, otherwise it is not. If no matching regexes are found for the method, the same logic is applied on the method's class name. \noindent If a method is annotated with \code{@Measured}, it is always instrumented with no exceptions (blacklist regexes are ignored in this case). If a class is annotated with \code{@Measured}, each of its methods is instrumented unless explicitly blacklisted.

\begin{lstlisting}[breaklines,caption={$MeasuringClassFileTransformer.isMethodMeasured$ implementation},label=lis:measuringclassfiletransformer:ismethodmeasured]
private boolean isMethodMeasured(CtClass ctClass, CtMethod ctMethod) {
 if (ctMethod.hasAnnotation(Measured.class)) {
  return true;
 }

 InstrumentationStatus methodInstrumentationStatus = getInstrumentationStatus(ctMethod.getLongName());
 if (methodInstrumentationStatus == InstrumentationStatus.WHITELISTED) {
  return true;
 }

 if (methodInstrumentationStatus == InstrumentationStatus.BLACKLISTED) {
  return false;
 }

 if (methodInstrumentationStatus == InstrumentationStatus.INDIFFERENT) {
  if (ctClass.hasAnnotation(Measured.class)) {
   return true;
  }

  InstrumentationStatus classInstrumentationStatus = getInstrumentationStatus(ctClass.getName());
  if (classInstrumentationStatus == InstrumentationStatus.WHITELISTED) {
   return true;
  }

  if (classInstrumentationStatus == InstrumentationStatus.BLACKLISTED) {
   return false;
  }
 }
    
 return false;
}

private InstrumentationStatus getInstrumentationStatus(String entityName) {
 int bestWhitelistMatch = findBestMatchingPatternLength(entityName, whitelistPatterns);
 int bestBlacklistMatch = findBestMatchingPatternLength(entityName, blacklistPatterns);
 if (bestWhitelistMatch == 0 && bestBlacklistMatch == 0) {
  return InstrumentationStatus.INDIFFERENT;
 }

 if (bestBlacklistMatch > bestWhitelistMatch) {
  return InstrumentationStatus.BLACKLISTED;
 }

 return InstrumentationStatus.WHITELISTED;
}

private int findBestMatchingPatternLength(final String input, final Set<Pattern> patternsSet) {
 return patternsSet
   .stream()
   .map(pattern -> pattern.matcher(input))
   .filter(Matcher::find)
   .map(matcher -> matcher.group(0).length())
   .mapToInt(i -> i)
   .max()
   .orElse(0);
}
\end{lstlisting}

\noindent When a method is elected for instrumentation, its implementation is changed to record measurements. The first approach (see Listing \ref{lis:measuringclassfiletransformer:firstmethodinstrumentationexample}) involved measuring time taken in nanoseconds and the thread \code{StackTrace} to the time reporter just before the method returned.

\begin{lstlisting}[breaklines,caption={Method instrumentation example (first approach)},label=lis:measuringclassfiletransformer:firstmethodinstrumentationexample]
$$@Measured
public void myMethod() {
 StackTraceElement[] _agent_stackTrace = Thread.currentThread().getStackTrace();
 long _agent_startTime = System.nanoTime();

 // Original implementation here

 _AGENT_TIME_RECORDER.reportTime(System.nanoTime() - _agent_startTime, _agent_stackTrace);
}
\end{lstlisting}

\noindent Benchmarks showed how this implementation always slowed down the instrumented method by a constant amount of time in the order of magnitude of \SI{10}{\micro\second} on a \SI{2.8}{\giga\hertz} machine. This is an enormous amount of time that would have a big impact on the observer effect, hence drastically compromising the time complexity calculation. Profiling the agent showed how the culprit is the call to get the stack trace.

\noindent The instrumentation logic has to be as light as possible to not have an impact on the measurement of the time complexity of the algorithm under test. The second approach (see Listing \ref{lis:measuringclassfiletransformer:secondmethodinstrumentationexample}) removes the slow call to get the stack trace and instead simply informs the time recorder of when the method has started and when it has finished, passing along the unique method long name (which consists of package name, class name, method name and arguments types). The time recorder will have more responsibilities and will be a bit more complicated because, on top of having to calculate the time taken it will also require to work out the stack trace of each time report. Delegating the complex logic to the time recorder is a much better approach as it can be done in a separate thread and/or after all the recording rounds have run, hence greatly reducing the observer effect.

\begin{lstlisting}[breaklines,caption={Method instrumentation example (second approach)},label=lis:measuringclassfiletransformer:secondmethodinstrumentationexample]
$$@Measured
public void myMethod() {
 _AGENT_TIME_RECORDER.methodStarted("myPackage.myClass.myMethod()");

 // Original implementation here

 _AGENT_TIME_RECORDER.methodFinished("myPackage.myClass.myMethod()");
}
\end{lstlisting}


\noindent The private method \code{instrumentMeasuredMethods} mentioned above returns a boolean indicating whether any of the methods in the class have been instrumented. If no methods have been instrumented, the \code{transform} method returns \code{null} meaning that the original instrumentation done in private method \code{declareAndInstantiateTimeRecorder} is undone.

\subsection{Limitations}
\label{sec:implementation:agent:limitations}
Some classes are pre-loaded in the JVM, such as some of the classes that are part of the Java standard library. Because they're pre-loaded, these classes don't go though the transformer and for that reason are never instrumented. Java could retransform pre-loaded classes but the documentation\footnote{\url{https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/Instrumentation.html}} states:

\enquote{The retransformation must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance}

\noindent Because \code{MeasuringClassFileTransformer} adds a field \code{\_AGENT\_TIME\_RECORDER}, retrasformation is not allowed and as a consequence any pre-loaded classes cannot be analysed. The field is not strictly necessary as it could simply be instantiated and initialised inside the instrumented method instead. Doing so would imply slowing down the each instrumented method as the initialisation takes CPU time.

\section{Time recorder API}
\label{sec:implementation:timerecorderapi}
The main responsibility of this module is to provide an abstraction over the actual time recording implementation. The main interface is shown in Listing \ref{lis:timerecorderapi:timerecorderinterface} and has 4 methods:
\begin{itemize}
  \item \textbf{\code{start}}: used when a new recording is starting, so that the internal data structures used by the implementation, if any, can be initialised
  \item \textbf{\code{methodStarted}}: used when a new instrumented method is starting doing its work. The subject instrumented method long name is passed to the implementation
  \item \textbf{\code{methodFinished}}: used when a new instrumented method is finished doing its work. The subject instrumented method long name is passed to the implementation
  \item \textbf{\code{stop}}: used when the current recording is finished (i.e. no more instrumented methods will start or stop from this point on). The implementation can then transform its internal data structures and return the recorded data as an instance of \code{MergeableTree<Measurement>} (see next sections)
\end{itemize}

\begin{lstlisting}[breaklines,caption={TimeRecorder interface},label=lis:timerecorderapi:timerecorderinterface]
public interface TimeRecorder {
 void start();

 void methodStarted(String methodLongName);
 void methodFinished(String methodLongName);

 MergeableTree<Measurement> stop() throws Exception;
}
\end{lstlisting}

\noindent As mentioned before, the time recorder implementation to use will be decided by the root module (Time complexity analyser). This means that  the algorithm under test, whose methods are instrumented, must not be tied to the time recorder implementation, but must rely on the API instead. The challenge that arises is then how to ensure that the instrumented methods have access to the time recorder implementation, in order to call its \code{methodStarted} and \code{methodFinished} methods. Usually, when an object needs to use another object in order to do its job, the former takes the latter as a constructor argument. An entity responsible for running the program will then ensure that all the long-lived objects (often called services) are created and passed correctly to the constructors of all the services. This pattern is known as dependency injection \footnote{\url{https://martinfowler.com/articles/injection.html}}. Unfortunately, this pattern cannot be applied in this circumstance, as none of the modules have control over how the objects inside the algorithm under test are instantiated.

\noindent A good alternative is to retrieve the implementation via the call to a public static method defined in the API, as previously seen in Listing \ref{lis:measuringclassfiletransformer:agenttimerecorder}. Again, the problem is that the API does not know about the implementation, but there is a small trick that allows this approach to work. The class \code{StaticTimeRecorderFactory} has a static method \code{getTimeRecorder()} to get the time recorder implementation. It is inspired by SLF4J \code{LoggerFactory}, which has a static method \code{getLogger(...)} to get the logger implementation\footnote{\url{https://github.com/qos-ch/slf4j/blob/master/slf4j-api/src/main/java/org/slf4j/LoggerFactory.java}}. When \code{StaticTimeRecorderFactory.getTimeRecorder()} is called, it uses \code{StaticTimeRecorderBinder} to get the time recorder implementation. The API contains a dummy implementation of \code{StaticTimeRecorderBinder} (see Listing \ref{lis:timerecorderapi:statictimerecorderbinderdummy}), but the idea is to swap this with the real implementation when the implementation is added as a Maven dependency. In fact this class is only used so that the whole module can be compiled, but the associated compiled \code{.class} file is removed just before packaging it inside the Maven artifact.

\begin{lstlisting}[breaklines,caption={StaticTimeRecorderBinder dummy implementation},label=lis:timerecorderapi:statictimerecorderbinderdummy]
package tech.dario.timecomplexityanalysis.timerecorder.impl;

public class StaticTimeRecorderBinder {
 private static final StaticTimeRecorderBinder SINGLETON = new StaticTimeRecorderBinder();

 public static final StaticTimeRecorderBinder getSingleton() {
  return SINGLETON;
 }

 private StaticTimeRecorderBinder() {
  throw new UnsupportedOperationException("This code should have never made it into time-recorder-api");
 }

 public TimeRecorder getTimeRecorder() {
  throw new UnsupportedOperationException("This code should never made it into time-recorder-api");
 }

 public String getTimeRecorderFactoryClassStr() {
  throw new UnsupportedOperationException("This code should never made it into time-recorder-api");
 }
}
\end{lstlisting}

\noindent In order for this trick to work, the time recorder implementation will have to define the class so that its fully qualified name is \code{tech/dario/timecomplexityanalysis/timerecorder/impl/StaticTimeRecorderBinder}. The class will need to define the same 3 public methods:

\begin{itemize}
  \item \textbf{\code{static} \code{StaticTimeRecorderBinder} \code{getSingleton()}}: used by \code{StaticTimeRecorderFactory} to get a singleton instance of the \code{StaticTimeRecorderBinder}
  \item \textbf{\code{TimeRecorder} \code{getTimeRecorder()}}: used to get the time recorder
  \item \textbf{\code{String} \code{getTimeRecorderClassStr()}} used to return the implementation name (purely used to distinguish it from other implementations)
\end{itemize}

\subsection{Data structures}
\label{sec:implementation:timerecorderapi:datastructures}

The API also offers some powerful data structures in order for other modules to be able to easily manage and transform the recorded data. Figure \ref{fig:timerecorerapi:datastructuresclassdiagram} shows a class diagram of all the different data structures that exist within this module. Note that this class diagram only shows inheritances and implementations and does not include associations, compositions and aggregations. It also omits information about the classes type parameters.

\begin{figure}
  \centering
  \begin{tikzpicture}[rotate=90, transform shape]
    \umlsimpleclass[y=0.0em, x=0.0em, width=9.0em, type=abstract]{AbstractNode}
    \umlsimpleinterface[y=0.0em, x=14.0em, width=9.0em]{Mergeable}
    \umlsimpleclass[y=0.0em, x=28.0em, width=9.0em, type=abstract]{AbstractTree}
    \umlsimpleclass[y=-12.0em, x=9.0em, width=9.0em]{MergeableList}
    \umlsimpleclass[y=-12.0em, x=19.0em, width=9.0em]{Measurement}
    \umlsimpleclass[y=-6.0em, x=-5.0em, width=9.0em]{SimpleNode}
    \umlsimpleclass[y=-6.0em, x=5.0em, width=9.0em]{MergeableNode}
    \umlsimpleclass[y=-6.0em, x=23.0em, width=9.0em]{MergeableTree}
    \umlsimpleclass[y=-6.0em, x=33.0em, width=9.0em]{SimpleTree}
    
    \umlinherit[geometry=|-|]{SimpleNode}{AbstractNode}
    \umlinherit[geometry=|-|]{MergeableNode}{AbstractNode}
    \umlimpl[geometry=|-|, anchor1=32]{MergeableNode}{Mergeable}
    
    \umlimpl[geometry=|-|, weight=0.3]{MergeableList}{Mergeable}
    \umlimpl[geometry=|-|, weight=0.3]{Measurement}{Mergeable}
    
    \umlimpl[geometry=|-|, anchor1=147]{MergeableTree}{Mergeable}
    \umlinherit[geometry=|-|]{MergeableTree}{AbstractTree}
    \umlinherit[geometry=|-|]{SimpleTree}{AbstractTree}
  \end{tikzpicture}
  \caption{Data structures class diagram}
  \label{fig:timerecorerapi:datastructuresclassdiagram}
\end{figure}

\subsubsection{AbstractNode}
\code{AbstractNode} is an abstract generic class defined as shown in Listing \ref{lis:timerecorderapi:abstractnodeclassdefinition}.

\begin{lstlisting}[breaklines,caption={AbstractNode class definition},label=lis:timerecorderapi:abstractnodeclassdefinition]
public abstract class AbstractNode<T, S extends AbstractNode<T, S>> {
 private final String name;
 private S parent;
 private T data;
 private Map<String, S> children;

 // ...
}
\end{lstlisting}

\noindent It has 2 type paramenters: \code{T} is the type of the data the node contains while \code{S} is the reference to the node type itself. The latter is useful mainly to make the definition a bit more clear and understandable.

\noindent It has a \code{name} field to uniquely identify it, a \code{parent} field to store the reference to its parent, a \code{data} field to store the data and a \code{children} field containing a reference to all the children. Children are stored in a \code{Map<String, S>} (where \code{S} is the type of the node), so that children can be looked up by name in constant time.

\noindent Besides basic methods such as \code{add(...)} and getters, this class has a powerful \code{map} method (shown in Listing \ref{lis:timerecorderapi:abstractnodemapmethoddefinition}) to return a copy of the node with a function applied to the node and each of its children, recursively.

\begin{lstlisting}[breaklines,caption={AbstractNode map method definition},label=lis:timerecorderapi:abstractnodemapmethoddefinition]
public <T2, S2 extends AbstractNode<T2, S2>> S2 map(Function<? super S, ? extends S2> mapper) {
 Queue<NodesPair<T, S, T2, S2>> queue = new LinkedList<>();

 S2 newRootNode = mapper.apply((S)this);

 queue.add(new NodesPair<>((S)this, newRootNode));

 while (!queue.isEmpty()) {
  NodesPair<T, S, T2, S2> nodes = queue.remove();

  S node = nodes.getNode1();
  S2 newNode = nodes.getNode2();

  for (S childNode : node.getChildren().values()) {
   S2 newChildNode = mapper.apply(childNode);
   newNode.add(newChildNode);
   queue.add(new NodesPair<>(childNode, newChildNode));
  }
 }

 return newRootNode;
}
\end{lstlisting}

\noindent The method uses a non-recursive implementation of Breadth-first search (BFS) \cite{EFM59} to traverse the tree. To start, the node and its transformed version (after applying the mapping function) are added to the BFS queue in an instance of \code{NodesPair}, a simple object that stores two nodes in memory (\code{node1} is the original one, \code{node2} is the transformed one). Then, every time an element is popped from the queue, a loop goes through all the \code{node1} children, applying the mapping function to each one of them. The transformed children are added to the \code{node2} that the BFS loop is currently visiting, and are also added to the BFS queue, again in instances of \code{NodesPair} together with their original counterparts.

\subsubsection{Mergeable}
\code{Mergeable} is an interface defined as shown in Listing \ref{lis:timerecorderapi:mergeableinterfacedefinition}.

\begin{lstlisting}[breaklines,caption={Mergeable interface definition},label=lis:timerecorderapi:mergeableinterfacedefinition]
public interface Mergeable<T extends Mergeable<T>> {
 T mergeWith(T mergeable);
}
\end{lstlisting}

\noindent It has a type parameter \code{T} that refers to its own type. It defines a \code{mergeWith(...)} that is needed to indicate that the classes implementing this interface are mergeable. When a class is mergeable, it needs to define a \code{mergeWith(...)} method, which takes another object of the same type, merges it with itself and returns the merged object. Useful usages of this interface will be presented in the following sections.

\subsubsection{AbstractTree}

\code{AbstractTree} is an abstract class defined as shown in Listing \ref{lis:timerecorderapi:abstracttreeclassdefinition}.

\begin{lstlisting}[breaklines,caption={AbstractTree class definition},label=lis:timerecorderapi:abstracttreeclassdefinition]
public abstract class AbstractTree<T, S extends AbstractNode<T, S>, R extends AbstractTree<T, S, R>> {
 protected S rootNode;
 
 // ...
}
\end{lstlisting}

\noindent It has 3 type paramenters: \code{T} is the type of the data the tree contains, \code{S} is the type of node the tree uses and \code{R} is the reference to the tree type itself. As per \code{AbstractNode}, both \code{S} and \code{R} are useful mainly to make the definition a bit more clear and understandable.

\noindent It has a single field \code{rootNode}, which stores the reference to the tree's root node.

\noindent Besides basic methods to add nodes and to get the root node, this class also has a powerful \code{map} method (shown in Listing \ref{lis:timerecorderapi:abstracttreemapmethoddefinition}) to return a copy of the tree with a function applied to each of its nodes.

\begin{lstlisting}[breaklines,caption={AbstractTree map method definition},label=lis:timerecorderapi:abstracttreemapmethoddefinition]
public <T2, S2 extends AbstractNode<T2, S2>, R2 extends AbstractTree<T2, S2, R2>> R2 map(Function<? super S2, ? extends R2> treeCreator, Function<? super S, ? extends S2> nodeMapper) {
 S2 newRootNote = rootNode.map(nodeMapper);
 return treeCreator.apply(newRootNote);
}
\end{lstlisting}

\noindent In this case the method takes two functions: \code{treeCreator} and \code{nodeMapper}. \code{treeCreator} takes the new root node as input and returns a new tree using that node as the root node. \code{nodeMapper} is the node transformer and is simply applied to the tree's root node via a call to its \code{map(...)} method shown before in Listing \ref{lis:timerecorderapi:abstractnodemapmethoddefinition}. The combination of the two returns a new tree with each of its node mapped using the supplied mapping function.

\subsubsection{SimpleNode}

\code{SimpleNode} is a concrete class defined as shown in Listing \ref{lis:timerecorderapi:simplenodeclassdefinition}.

\begin{lstlisting}[breaklines,caption={SimpleNode class definition},label=lis:timerecorderapi:simplenodeclassdefinition]
public class SimpleNode<T> extends AbstractNode<T, SimpleNode<T>> {
 public SimpleNode(final String name) {
  this(name, null);
 }

 public SimpleNode(final String name, final T data) {
  super(name, data);
 }
}
\end{lstlisting}

\noindent As the name suggests, it's the simplest possible implementation of \code{AbstractNode}. It represent a simple node that stores data of type \code{T}.

\subsubsection{MergeableNode}

\code{MergeableNode} is a concrete class defined as shown in Listing \ref{lis:timerecorderapi:mergeablenodeclassdefinition}.

\begin{lstlisting}[breaklines,caption={MergeableNode class definition},label=lis:timerecorderapi:mergeablenodeclassdefinition]
public class MergeableNode<T extends Mergeable<T>> extends AbstractNode<T, MergeableNode<T>> implements Mergeable<MergeableNode<T>> {
 public MergeableNode(String name) {
  this(name, null);
 }

 public MergeableNode(String name, T data) {
  super(name, data);
 }

 public void addData(T data) {
  mergeData(data);
 }
  
 // ...

 private void mergeData(T otherData) {
  if (!this.hasData()) {
    setData(otherData);
  } else if (otherData != null) {
    setData(getData().mergeWith(otherData));
  }
 }
\end{lstlisting}

\noindent This class represents a node that can be merged with another node of the same type. It has a type parameter \code{T}, where \code{T} has to be a class that implements \code{Mergeable}. On top of all methods offered by \code{AbstractNode}, which this class extends, it allows adding data to the node. If the node already has data, it is merged with the new value, otherwise the new value is just set as the node data.

\noindent Because this class itself implements the \code{Mergeable} interface, it needs to implement a \code{mergeWith(...)} method, shown in Listing \ref{lis:timerecorderapi:mergeablenodemergewithmethoddefinition}.

\begin{lstlisting}[breaklines,caption={MergeableNode mergeWith method definition},label=lis:timerecorderapi:mergeablenodemergewithmethoddefinition]
$$@Override
public MergeableNode<T> mergeWith(MergeableNode<T> otherNode) {
 if (otherNode == null) {
  return this;
 }

 if (!getName().equals(otherNode.getName())) {
  String message = String.format("Cannot merge MergeableNode '%s' with MergeableNode '%s' as names are different", getName(), otherNode.getName());
  throw new RuntimeException(message);
 }

 MergeableNode<T> mergedNode = new MergeableNode<>(getName(), getData());

 // Merge node data
 mergedNode.mergeData(otherNode.getData());

 // Add all children that are in this node, merging them with the ones in the other node when they exist
 for (Map.Entry<String, MergeableNode<T>> child : getChildren().entrySet()) {
  String childName = child.getKey();
  if (otherNode.hasChild(childName)) {
   mergedNode.add(child.getValue().mergeWith(otherNode.getChild(childName)));
  } else {
   mergedNode.add(child.getValue());
  }
 }

 // Add all children that are in otherNode but not in this node
 for (Map.Entry<String, MergeableNode<T>> child : otherNode.getChildren().entrySet()) {
  String childName = child.getKey();
  if (!mergedNode.hasChild(childName)) {
   mergedNode.add(child.getValue());
  }
 }

 return mergedNode;
}
\end{lstlisting}

\noindent First, the subject node's data is merged with the other node's data. Then, for each child in the subject node, the correspondent child (i.e. with the same name) is looked up in the other node and if found they are merged using the \code{mergeWith(...)} method. If not found, the subject node's data is used instead. Because there could be some children in the other node that are not present in the subject node, it is necessary to loop through all the children in the other node that are not present in the current node and add them to the merged node. Note that because there is a recursive call to the \code{mergeWith(...)} method, the whole node hierarchy will be merged.

\subsubsection{MergeableTree}

\code{MergeableTree} is a concrete class defined as shown in Listing \ref{lis:timerecorderapi:mergeabletreeclassdefinition}.

\begin{lstlisting}[breaklines,caption={MergeableTree class definition},label=lis:timerecorderapi:mergeabletreeclassdefinition]
public class MergeableTree<T extends Mergeable<T>> extends AbstractTree<T, MergeableNode<T>, MergeableTree<T>> implements Mergeable<MergeableTree<T>> {
 public MergeableTree() {
  this(new MergeableNode<>("root", null));
 }

 public MergeableTree(MergeableNode<T> rootNode) {
  super(rootNode);
 }

 $$@Override
 public MergeableTree<T> mergeWith(MergeableTree<T> otherTree) {
  MergeableNode<T> otherRootNode = null;
  if (otherTree != null) {
   otherRootNode = otherTree.getRootNode();
  }
  return new MergeableTree<>(getRootNode().mergeWith(otherRootNode));
 }
}
\end{lstlisting}

\noindent This class represents a tree that can be merged with another tree of the same type. It has a type parameter \code{T}, where \code{T} has to be a class that implements \code{Mergeable}. It extends \code{AbstractTree} and, given it also implements the \code{Mergeable} interface, on top of all methods offered by \code{AbstractTree} it needs to implement a \code{mergeWith(...)} method. The \code{mergeWith(...)} method simply merges the root node of the subject tree with the root node of the other tree and then returns a new instance of \code{MergeableTree}, with the merged node as the root node.

\subsubsection{SimpleTree}

\code{SimpleTree} is a concrete class defined as shown in Listing \ref{lis:timerecorderapi:simpletreeclassdefinition}.

\begin{lstlisting}[breaklines,caption={SimpleTree class definition},label=lis:timerecorderapi:simpletreeclassdefinition]
public class SimpleTree<T> extends AbstractTree<T, SimpleNode<T>, SimpleTree<T>> {
 public SimpleTree() {
  this(new SimpleNode<>("root", null));
 }

 public SimpleTree(SimpleNode<T> rootNode) {
  super(rootNode);
 }
}
\end{lstlisting}

\noindent As the name suggests, it's the simplest possible implementation of \code{AbstractTree}. It represent a simple tree that stores data of type \code{T}.

\subsubsection{MergeableList}

\code{MergeableList} is a concrete class defined as shown in Listing \ref{lis:timerecorderapi:mergeablelistclassdefinition}.

\begin{lstlisting}[breaklines,caption={MergeableList class definition},label=lis:timerecorderapi:mergeablelistclassdefinition]
public class MergeableList<T> implements Mergeable<MergeableList<T>> {
 private List<T> list;

 // ...

 $$@Override
 public MergeableList<T> mergeWith(MergeableList<T> otherList) {
  List<T> newList = new ArrayList<>(size() + otherList.size());
  newList.addAll(list);
  newList.addAll(otherList.getList());
  return new MergeableList<>(newList);
 }

 // ...
}
\end{lstlisting}

\noindent It represents a list that can be merged with another list of the same type. It encapsulates a generic \code{List<T>} and it implements the \code{Mergeable} interface. The merging strategy, defined in method \code{mergeWith(...)}, creates a new \code{MergeableList}, encapsulating a new \code{List<T>} made of the subject list' elements appended to the other list's elements. This guarantees that both the subject and the other list are not modified, as that could cause unexpected behaviours.

\subsubsection{Measurement}

\code{Measurement} is a concrete class defined as shown in Listing \ref{lis:timerecorderapi:measurementclassdefinition}.

\begin{lstlisting}[breaklines,caption={Measurement class definition},label=lis:timerecorderapi:measurementclassdefinition]
public class Measurement implements Mergeable<Measurement> {
 private final double count;
 private final double total;

 // ...

 @Override
 public Measurement mergeWith(Measurement otherMeasurement) {
  double newCount = count + otherMeasurement.count;
  double newTotal = total + otherMeasurement.total;
  return new Measurement(newCount, newTotal);
 }

 // ...
}
\end{lstlisting}

\noindent It represent a measurement, as defined in Section \ref{sec:requirementanalysis:definitions:measurement}. It is useful for the time recorder implementation to store how many times a method has been called (\code{count}) and the total amount of time spent inside the method (\code{total}. Because it implements the \code{Mergeable} interface, when two measurements are merged, the subject \code{count} is summed with the other \code{count} and the subject \code{total} is summed with the other \code{total}. A new instance of \code{Measurement} containing the new values is returned, in order to guarantee immutability.

\section{Time recorder implementation}
\label{sec:implementation:timerecorderimplementation}

TODO by 21/07


\section{Time complexity analysis SDK}

TODO by 07/08


\section{Algorithm under test}

TODO by 14/08


\section{Time complexity analyser}
\label{sec:implementation:timecomplexityanalyser} 
TODO by 21/08
